'use client';

import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import { type GameState, type Difficulty, AUDIO_FILES } from '@/types/game';
import {
  playAudio,
  sleep,
  isValidLetter,
  normalizeKey,
  isRowComplete,
  isGameWon,
  createEmptyCell,
  getWordFromUrl
} from '@/lib/gameUtils';
import { dictionaryService, type DictionaryValidationResult } from '@/lib/dictionaryService';
import { dailyChallengeService } from '@/lib/dailyChallenge';
import { gameSessionAPI } from '@/services/api';
import type { ApiResponse, GameSession, GuessResponse, GameStats, EndGameData } from '@/types';

const CHECK_DELAY = 270;

type GameMode = 'main-menu' | 'playing';

// === WordleÂèåËâ≤ÂàÜÈÖçÁÆóÊ≥ï ===
function computeLetterStates(cells: { letter: string }[], targetWord: string): ('found' | 'wrong' | 'not-found')[] {
  const resultStates = Array<'found' | 'wrong' | 'not-found'>(cells.length).fill('not-found');
  const targetArr = targetWord.split('');
  const used = Array(targetArr.length).fill(false);
  
  // Pass 1: Ê†áËÆ∞ found
  for (let i = 0; i < cells.length; i++) {
    const cell = cells[i];
    const targetChar = targetArr[i];
    if (cell && targetChar && cell.letter === targetChar) {
      resultStates[i] = 'found';
      used[i] = true;
    }
  }
  
  // Pass 2: Ê†áËÆ∞ wrong
  for (let i = 0; i < cells.length; i++) {
    const cell = cells[i];
    if (resultStates[i] === 'found' || !cell) continue;
    const idx = targetArr.findIndex((ch, j) => ch === cell.letter && !used[j]);
    if (idx !== -1) {
      resultStates[i] = 'wrong';
      used[idx] = true;
    }
  }
  
  return resultStates;
}

// ÂÆö‰πâ GameContext ÁöÑÁ±ªÂûã
interface GameContextType {
  // Ê∏∏ÊàèÁä∂ÊÄÅ
  gameState: GameState | null;
  sessionId: string | null;
  gameMode: GameMode;
  selectedDifficulty: Difficulty | null;
  lastPlayedDifficulty: Difficulty | null;
  isChecking: boolean;
  isValidating: boolean;
  isLoadingWord: boolean;
  validationResult: DictionaryValidationResult | null;
  isDailyChallenge: boolean;
  endGameData: EndGameData | null;
  
  // Ê∏∏ÊàèÊéßÂà∂
  handleKeyInput: (key: string) => void;
  handleVirtualKeyboard: (action: string) => void;
  closeValidationResult: () => void;
  handleGameComplete: (won: boolean, attempts: number, providedEndGameData?: EndGameData | null) => Promise<void>;
  
  // Ê®°ÂºèÂàáÊç¢
  returnToMainMenu: () => void;
  
  // ÈöæÂ∫¶ÂíåÊ∏∏ÊàèÁÆ°ÁêÜ
  handleDifficultySelect: (difficulty: Difficulty) => void;
  startNewGame: () => Promise<void>;
  startDailyChallenge: () => Promise<void>;
  quickStart: () => Promise<void>;
  restartGame: () => Promise<void>;
  returnToDifficultySelection: () => void;
  getGameStats: () => Promise<GameStats | null>;
}

// ÂàõÂª∫ Context
const GameContext = createContext<GameContextType | null>(null);

// GameProvider ÁªÑ‰ª∂
export const GameProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [gameState, setGameState] = useState<GameState | null>(null);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [isChecking, setIsChecking] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [validationResult, setValidationResult] = useState<DictionaryValidationResult | null>(null);
  const [selectedDifficulty, setSelectedDifficulty] = useState<Difficulty | null>(null);
  const [lastPlayedDifficulty, setLastPlayedDifficulty] = useState<Difficulty | null>(null);
  const [isLoadingWord, setIsLoadingWord] = useState(false);
  const [gameMode, setGameMode] = useState<GameMode>('main-menu');
  const [isDailyChallenge, setIsDailyChallenge] = useState(false);
  const [endGameData, setEndGameData] = useState<EndGameData | null>(null);
  const [gameCompleteProcessing, setGameCompleteProcessing] = useState(false);
  const endGameDataRef = useRef<EndGameData | null>(null);

  // ÂàõÂª∫‰∏Ä‰∏™ËÆæÁΩÆendGameDataÁöÑËæÖÂä©ÂáΩÊï∞
  const setEndGameDataWithRef = useCallback((data: EndGameData | null) => {
    endGameDataRef.current = data;
    setEndGameData(data);
  }, []);

  // ‰ªélocalStorageÂä†ËΩΩ‰∏äÊ¨°ÈÄâÊã©ÁöÑÈöæÂ∫¶
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const savedDifficulty = localStorage.getItem('sutom-last-difficulty');
      if (savedDifficulty && ['easy', 'medium', 'hard'].includes(savedDifficulty)) {
        setLastPlayedDifficulty(savedDifficulty as Difficulty);
      }
    }
  }, []);

  // ÂàõÂª∫Â∏¶ÈöæÂ∫¶ÁöÑÂàùÂßãÊ∏∏ÊàèÁä∂ÊÄÅ
  const createInitialGameStateWithDifficulty = useCallback((word: string, difficulty: Difficulty | null): GameState => {
    const lettersCount: Record<string, number> = {};
    
    // ÁªüËÆ°ÁõÆÊ†áÂçïËØç‰∏≠ÊØè‰∏™Â≠óÊØçÁöÑÂá∫Áé∞Ê¨°Êï∞
    for (const letter of word) {
      lettersCount[letter] = (lettersCount[letter] ?? 0) + 1;
    }
    
    // ÂàõÂª∫ÊâÄÊúâ6Ë°åÔºåÁ¨¨‰∏ÄË°åÁ¨¨‰∏Ä‰∏™Â≠óÊØçÂ∑≤ÊòæÁ§∫ÔºåÂÖ∂‰ΩôË°å‰∏∫Á©∫
    const maxAttempts = 6;
    const rows = Array.from({ length: maxAttempts }, (_, index) => {
      if (index === 0) {
        // Á¨¨‰∏ÄË°åÔºöÁ¨¨‰∏Ä‰∏™Â≠óÊØçÂ∑≤ÊòæÁ§∫
        return {
          cells: word.split('').map((letter, cellIndex) => 
            createEmptyCell(cellIndex === 0 ? letter : '.')
          ),
          isCompleted: false
        };
      } else {
        // ÂÖ∂‰ΩôË°åÔºöÁ¨¨‰∏Ä‰∏™Â≠óÊØçÊòæÁ§∫ÔºåÂÖ∂‰Ωô‰∏∫Á©∫
        return {
          cells: word.split('').map((_, cellIndex) => 
            createEmptyCell(cellIndex === 0 ? word.charAt(0) : '.')
          ),
          isCompleted: false
        };
      }
    });
    
    return {
      targetWord: word,
      difficulty,
      currentRow: 0,
      rows,
      gameStatus: 'playing',
      lettersCount,
      lettersFound: {},
      keyboardStates: {}
    };
  }, []);

  // ËøîÂõû‰∏ªËèúÂçï
  const returnToMainMenu = useCallback(() => {
    setGameMode('main-menu');
    setGameState(null);
    setSessionId(null);
    setSelectedDifficulty(null);
    setValidationResult(null);
    setIsDailyChallenge(false);
    setEndGameDataWithRef(null);
    setGameCompleteProcessing(false);
  }, [setEndGameDataWithRef]);

  // ÈÄâÊã©ÈöæÂ∫¶
  const handleDifficultySelect = useCallback((difficulty: Difficulty) => {
    setSelectedDifficulty(difficulty);
  }, []);

  // ÂºÄÂßãÊñ∞Ê∏∏Êàè
  const startNewGame = useCallback(async () => {
    if (!selectedDifficulty) return;
    
    console.log('üéÆ startNewGame called with difficulty:', selectedDifficulty);
    
    setIsLoadingWord(true);
    if (gameState?.gameStatus !== 'won' && gameState?.gameStatus !== 'lost') {
      setEndGameDataWithRef(null);
    }
    setGameCompleteProcessing(false);
    
    try {
      // ‰øùÂ≠òÁî®Êà∑ÈÄâÊã©ÁöÑÈöæÂ∫¶
      if (typeof window !== 'undefined') {
        localStorage.setItem('sutom-last-difficulty', selectedDifficulty);
        setLastPlayedDifficulty(selectedDifficulty);
      }
      
      // Ë∞ÉÁî®ÂêéÂè∞ API ÂºÄÂßãÊ∏∏Êàè
      try {
        const response = await gameSessionAPI.startGame({
          difficulty: selectedDifficulty,
          maxAttempts: 6
        });
        
        if (response.success && response.data) {
          const { sessionId: newSessionId, wordData, gameInfo } = response.data;
          const newGameState = createInitialGameStateWithDifficulty(wordData.maskedWord, selectedDifficulty);
          
          console.log('üéÆ API response received:', response.data);
          setGameState(newGameState);
          setSessionId(newSessionId);
          setGameMode('playing');
          
          // ‰øùÂ≠ò sessionId Âà∞ localStorage
          if (typeof window !== 'undefined') {
            localStorage.setItem('sutom-session-id', newSessionId);
          }
        } else {
          throw new Error(response.message || 'APIË∞ÉÁî®Â§±Ë¥•');
        }
      } catch (error) {
        console.warn('APIË∞ÉÁî®Â§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞Ê®°Âºè:', error);
        // ‰ΩøÁî®Êú¨Âú∞Ê®°Âºè‰Ωú‰∏∫ fallback
        const fallbackWord = selectedDifficulty === 'easy' ? 'chat' : 
                            selectedDifficulty === 'medium' ? 'ordinateur' : 'cacophonie';
        const newGameState = createInitialGameStateWithDifficulty(fallbackWord, selectedDifficulty);
        console.log('üéÆ Using local mode with fallback word:', fallbackWord);
        setGameState(newGameState);
        setGameMode('playing');
        setSessionId(null);
      }
    } finally {
      setIsLoadingWord(false);
    }
  }, [selectedDifficulty, createInitialGameStateWithDifficulty, gameState, setEndGameDataWithRef]);

  // ÂºÄÂßãÊØèÊó•ÊåëÊàò
  const startDailyChallenge = useCallback(async () => {
    const canPlay = await dailyChallengeService.canPlayToday();
    if (!canPlay) {
      return;
    }

    setIsLoadingWord(true);
    if (gameState?.gameStatus !== 'won' && gameState?.gameStatus !== 'lost') {
      setEndGameDataWithRef(null);
    }
    setGameCompleteProcessing(false);
    
    try {
      const challengeData = await dailyChallengeService.getTodayChallenge();
      const newGameState = createInitialGameStateWithDifficulty(challengeData.word, null);
      setGameState(newGameState);
      setGameMode('playing');
      setIsDailyChallenge(true);
      setSessionId(challengeData.sessionId);
    } catch (error) {
      console.error('Ëé∑ÂèñÊØèÊó•ÊåëÊàòÂ§±Ë¥•:', error);
    } finally {
      setIsLoadingWord(false);
    }
  }, [createInitialGameStateWithDifficulty, gameState, setEndGameDataWithRef]);

  // Âø´ÈÄüÂºÄÂßã
  const quickStart = useCallback(async () => {
    const difficulty = lastPlayedDifficulty ?? 'medium';
    
    if (typeof window !== 'undefined') {
      localStorage.setItem('sutom-last-difficulty', difficulty);
      setLastPlayedDifficulty(difficulty);
    }

    setIsLoadingWord(true);
    if (gameState?.gameStatus !== 'won' && gameState?.gameStatus !== 'lost') {
      setEndGameDataWithRef(null);
    }
    setGameCompleteProcessing(false);
    
    try {
      // Ë∞ÉÁî®ÂêéÂè∞ API ÂºÄÂßãÊ∏∏Êàè
      try {
        const response = await gameSessionAPI.startGame({
          difficulty,
          maxAttempts: 6
        });
        
        if (response.success && response.data) {
          const { sessionId: newSessionId, wordData, gameInfo } = response.data;
          const newGameState = createInitialGameStateWithDifficulty(wordData.maskedWord, difficulty);
          
          console.log('üéÆ QuickStart API response received:', response.data);
          setSelectedDifficulty(difficulty);
          setGameState(newGameState);
          setSessionId(newSessionId);
          setGameMode('playing');
          
          // ‰øùÂ≠ò sessionId Âà∞ localStorage
          if (typeof window !== 'undefined') {
            localStorage.setItem('sutom-session-id', newSessionId);
          }
        } else {
          throw new Error(response.message || 'APIË∞ÉÁî®Â§±Ë¥•');
        }
      } catch (error) {
        console.warn('Âø´ÈÄüÂºÄÂßã APIË∞ÉÁî®Â§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞Ê®°Âºè:', error);
        // ‰ΩøÁî®Êú¨Âú∞Ê®°Âºè‰Ωú‰∏∫ fallback
        const fallbackWord = difficulty === 'easy' ? 'chat' : 
                            difficulty === 'medium' ? 'ordinateur' : 'cacophonie';
        const newGameState = createInitialGameStateWithDifficulty(fallbackWord, difficulty);
        console.log('üéÆ QuickStart using local mode with fallback word:', fallbackWord);
        setSelectedDifficulty(difficulty);
        setGameState(newGameState);
        setGameMode('playing');
        setSessionId(null);
      }
    } finally {
      setIsLoadingWord(false);
    }
  }, [lastPlayedDifficulty, createInitialGameStateWithDifficulty, gameState, setEndGameDataWithRef]);

  // ËøîÂõûÈöæÂ∫¶ÈÄâÊã©
  const returnToDifficultySelection = useCallback(() => {
    setGameMode('main-menu');
    setGameState(null);
    setSelectedDifficulty(null);
    setValidationResult(null);
    setEndGameDataWithRef(null);
    setGameCompleteProcessing(false);
  }, [setEndGameDataWithRef]);

  // ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè
  const restartGame = useCallback(async () => {
    if (isDailyChallenge) {
      await startDailyChallenge();
    } else if (selectedDifficulty) {
      await startNewGame();
    }
  }, [isDailyChallenge, selectedDifficulty, startDailyChallenge, startNewGame]);

  // Â§ÑÁêÜÊ∏∏ÊàèÂÆåÊàê
  const handleGameComplete = useCallback(async (won: boolean, attempts: number, providedEndGameData?: EndGameData | null) => {
    if (providedEndGameData) {
      setEndGameDataWithRef(providedEndGameData);
    } else if (sessionId) {
      // API Ê®°Âºè‰∏ãÔºåË∞ÉÁî® endGame Êé•Âè£Ëé∑ÂèñÂÆåÊï¥ÁªüËÆ°Êï∞ÊçÆ
      try {
        const endGameResponse = await gameSessionAPI.endGame(sessionId);
        if (endGameResponse.success && endGameResponse.data) {
          setEndGameDataWithRef(endGameResponse.data);
        } else {
          // Â¶ÇÊûú endGame API Â§±Ë¥•ÔºåÁîüÊàêÂü∫Êú¨ÁöÑ endGameData
          const basicEndGameData: EndGameData = {
            sessionId,
            isWon: won,
            attempts,
            gameTime: attempts * 30,
            wordInfo: {
              word: gameState?.targetWord ?? 'unknown',
              difficulty: gameState?.difficulty ?? 'medium',
              length: gameState?.targetWord?.length ?? 4,
              definition: 'APIÊ®°Âºè‰∏ãÊöÇÊó†ÂÆö‰πâ‰ø°ÊÅØ',
              category: 'Âú®Á∫øÊ∏∏Êàè'
            },
            wordStats: {
              totalAttempts: attempts,
              totalSuccesses: won ? 1 : 0,
              successRate: won ? 100 : 0,
              averageAttempts: attempts,
              averageGameTime: attempts * 30,
              perceivedDifficulty: gameState?.difficulty === 'easy' ? 3 : gameState?.difficulty === 'medium' ? 5 : 7,
              sampleSize: 1,
              lastPlayedAt: new Date().toISOString()
            }
          };
          setEndGameDataWithRef(basicEndGameData);
        }
      } catch (error) {
        console.error('Ë∞ÉÁî® endGame API Â§±Ë¥•:', error);
        // ÁîüÊàêÂü∫Êú¨ÁöÑ endGameData
        const basicEndGameData: EndGameData = {
          sessionId,
          isWon: won,
          attempts,
          gameTime: attempts * 30,
          wordInfo: {
            word: gameState?.targetWord ?? 'unknown',
            difficulty: gameState?.difficulty ?? 'medium',
            length: gameState?.targetWord?.length ?? 4,
            definition: 'APIË∞ÉÁî®Â§±Ë¥•',
            category: 'Âú®Á∫øÊ∏∏Êàè'
          },
          wordStats: {
            totalAttempts: attempts,
            totalSuccesses: won ? 1 : 0,
            successRate: won ? 100 : 0,
            averageAttempts: attempts,
            averageGameTime: attempts * 30,
            perceivedDifficulty: gameState?.difficulty === 'easy' ? 3 : gameState?.difficulty === 'medium' ? 5 : 7,
            sampleSize: 1,
            lastPlayedAt: new Date().toISOString()
          }
        };
        setEndGameDataWithRef(basicEndGameData);
      }
    } else {
      // Êú¨Âú∞Ê®°Âºè‰∏ãÁîüÊàêÂü∫Êú¨ÁöÑendGameData
      const localEndGameData: EndGameData = {
        sessionId: 'local-session',
        isWon: won,
        attempts,
        gameTime: attempts * 30,
        wordInfo: {
          word: gameState?.targetWord ?? 'unknown',
          difficulty: gameState?.difficulty ?? 'medium',
          length: gameState?.targetWord?.length ?? 4,
          definition: 'Êú¨Âú∞Ê®°Âºè‰∏ãÊöÇÊó†ÂÆö‰πâ‰ø°ÊÅØ',
          category: 'Êú¨Âú∞Ê∏∏Êàè'
        },
        wordStats: {
          totalAttempts: attempts,
          totalSuccesses: won ? 1 : 0,
          successRate: won ? 100 : 0,
          averageAttempts: attempts,
          averageGameTime: attempts * 30,
          perceivedDifficulty: gameState?.difficulty === 'easy' ? 3 : gameState?.difficulty === 'medium' ? 5 : 7,
          sampleSize: 1,
          lastPlayedAt: new Date().toISOString()
        }
      };
      
      setEndGameDataWithRef(localEndGameData);
    }

    // Êõ¥Êñ∞ÊØèÊó•ÊåëÊàòÁä∂ÊÄÅ
    if (isDailyChallenge && gameState) {
      const guesses = gameState.rows
        .filter(row => row.isCompleted)
        .map(row => row.cells.map(cell => cell.letter).join(''));
      
      await dailyChallengeService.updateTodayChallenge({
        completed: true,
        won,
        attempts,
        guesses
      });
    }
  }, [isDailyChallenge, gameState, sessionId, setEndGameDataWithRef]);

  // ÁÆÄÂåñÁöÑÈîÆÁõòËæìÂÖ•ÂíåÊ∏∏ÊàèÈÄªËæë
  const handleKeyInput = useCallback((key: string) => {
    console.log('üéÆ handleKeyInput Ë¢´Ë∞ÉÁî®:', key);
    if (!gameState || isChecking || gameState.gameStatus !== 'playing') return;

    if (key === 'Enter') {
      console.log('üéÆ EnterÈîÆË¢´Êåâ‰∏ãÔºåË∞ÉÁî® checkWord');
      void checkWord();
    } else if (key === 'Backspace') {
      removeLetter();
    } else if (isValidLetter(key)) {
      addLetter(key);
    }
  }, [gameState, isChecking]);

  const handleVirtualKeyboard = useCallback((action: string) => {
    console.log('üéÆ handleVirtualKeyboard Ë¢´Ë∞ÉÁî®:', action);
    if (!gameState || isChecking || gameState.gameStatus !== 'playing') return;

    if (action === 'enter') {
      console.log('üéÆ ËôöÊãüÈîÆÁõò Enter Ë¢´ÁÇπÂáªÔºåË∞ÉÁî® checkWord');
      void checkWord();
    } else if (action === 'backspace') {
      removeLetter();
    } else {
      addLetter(action);
    }
  }, [gameState, isChecking]);

  // Ê∑ªÂä†Â≠óÊØç
  const addLetter = useCallback((letter: string) => {
    if (!gameState || isChecking || gameState.gameStatus !== 'playing') return;

    const normalizedLetter = normalizeKey(letter);
    const currentRow = gameState.rows[gameState.currentRow];
    
    if (!currentRow) return;

    const emptyCellIndex = currentRow.cells.findIndex(cell => cell.letter === '.');
    if (emptyCellIndex === -1) return;

    setGameState(prev => {
      if (!prev) return prev;
      
      const newRows = [...prev.rows];
      const newRow = { ...newRows[prev.currentRow]! };
      const newCells = [...newRow.cells];
      
      newCells[emptyCellIndex] = {
        ...newCells[emptyCellIndex]!,
        letter: normalizedLetter
      };
      
      newRow.cells = newCells;
      newRows[prev.currentRow] = newRow;
      
      return { ...prev, rows: newRows };
    });
  }, [gameState, isChecking]);

  // Âà†Èô§Â≠óÊØç
  const removeLetter = useCallback(() => {
    if (!gameState || isChecking || gameState.gameStatus !== 'playing') return;

    const currentRow = gameState.rows[gameState.currentRow];
    if (!currentRow) return;

    const cellsAfterFirst = currentRow.cells.slice(1);
    let lastFilledIndex = -1;
    
    for (let i = cellsAfterFirst.length - 1; i >= 0; i--) {
      if (cellsAfterFirst[i]?.letter !== '.') {
        lastFilledIndex = i;
        break;
      }
    }
    
    if (lastFilledIndex === -1) return;

    const actualIndex = lastFilledIndex + 1;

    setGameState(prev => {
      if (!prev) return prev;
      
      const newRows = [...prev.rows];
      const newRow = { ...newRows[prev.currentRow]! };
      const newCells = [...newRow.cells];
      
      newCells[actualIndex] = {
        ...newCells[actualIndex]!,
        letter: '.'
      };
      
      newRow.cells = newCells;
      newRows[prev.currentRow] = newRow;
      
      return { ...prev, rows: newRows };
    });
  }, [gameState, isChecking]);

  // Ê£ÄÊü•ÂçïËØç
  const checkWord = useCallback(async () => {
    console.log('üéÆ checkWord Ë¢´Ë∞ÉÁî®');
    console.log('üéÆ ÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅ:', { gameState: !!gameState, isChecking, gameStatus: gameState?.gameStatus });
    console.log('üéÆ ÂΩìÂâç sessionId:', sessionId);
    
    if (!gameState || isChecking || gameState.gameStatus !== 'playing') return;

    const currentRow = gameState.rows[gameState.currentRow];
    if (!currentRow || !isRowComplete(currentRow.cells)) return;

    setIsChecking(true);
    setGameCompleteProcessing(false);

    try {
      const currentWord = currentRow.cells.map(cell => cell.letter).join('');
      console.log('üéÆ ÂáÜÂ§áÈ™åËØÅÂçïËØç:', currentWord);
      
      const newCells = [...currentRow.cells];
      const newKeyboardStates = { ...gameState.keyboardStates };

      // Â¶ÇÊûúÊúâ sessionIdÔºå‰ΩøÁî® API È™åËØÅÔºõÂê¶ÂàôËøõË°åËØçÂÖ∏È™åËØÅ
      if (sessionId) {
        console.log('üéÆ Êúâ sessionIdÔºåË∑≥ËøáËØçÂÖ∏È™åËØÅÔºåÁõ¥Êé•Ë∞ÉÁî®API');
        try {
          console.log('üéÆ Êèê‰∫§ÁåúÊµãÂà∞API:', { sessionId, guess: currentWord });
          const response = await gameSessionAPI.submitGuess({
            sessionId,
            guess: currentWord
          });
          
          console.log('üéÆ API ÂìçÂ∫î:', response);
          
          if (response.success && response.data) {
            const { letterAnalysis, isCorrect, isCompleted, isWon: apiIsWon, wordStats } = response.data;
            
            // ‰ΩøÁî® API ËøîÂõûÁöÑÂ≠óÊØçÂàÜÊûêÁªìÊûú
            for (let i = 0; i < letterAnalysis.length; i++) {
              await sleep(CHECK_DELAY);
              const analysis = letterAnalysis[i];
              if (analysis && newCells[i]) {
                const state = analysis.status === 'correct' ? 'found' : 
                            analysis.status === 'wrong-position' ? 'wrong' : 'not-found';
                newCells[i] = { ...newCells[i]!, state };
                newKeyboardStates[analysis.letter] = state;
                
                switch (state) {
                  case 'found': playAudio(AUDIO_FILES.found); break;
                  case 'wrong': playAudio(AUDIO_FILES.wrong); break;
                  case 'not-found': playAudio(AUDIO_FILES.notFound); break;
                }
              }
            }
            
            // Êõ¥Êñ∞Ê∏∏ÊàèÁä∂ÊÄÅ
            setGameState(prev => {
              if (!prev) return prev;
              
              const newRows = [...prev.rows];
              newRows[prev.currentRow] = {
                ...newRows[prev.currentRow]!,
                cells: newCells,
                isCompleted: true
              };
              
              let newGameStatus = prev.gameStatus;
              let newCurrentRow = prev.currentRow;
              
              if (isCompleted) {
                newGameStatus = apiIsWon ? 'won' : 'lost';
                if (apiIsWon) {
                  playAudio(AUDIO_FILES.win);
                }
              } else {
                newCurrentRow = prev.currentRow + 1;
              }
              
              return {
                ...prev,
                rows: newRows,
                currentRow: newCurrentRow,
                gameStatus: newGameStatus,
                keyboardStates: newKeyboardStates
              };
            });
            
            // Â¶ÇÊûúÊ∏∏ÊàèÂÆåÊàêÔºåË∞ÉÁî® endGame API Ëé∑ÂèñÂÆåÊï¥ÁªüËÆ°Êï∞ÊçÆ
            if (isCompleted) {
              try {
                const endGameResponse = await gameSessionAPI.endGame(sessionId);
                if (endGameResponse.success && endGameResponse.data) {
                  void handleGameComplete(apiIsWon, response.data.attempts, endGameResponse.data);
                } else {
                  // Â¶ÇÊûú endGame API Â§±Ë¥•Ôºå‰ΩøÁî®‰ªé guess API Ëé∑ÂèñÁöÑÊï∞ÊçÆ
                  if (response.data.correctAnswer && wordStats) {
                    const endGameData: EndGameData = {
                      sessionId,
                      isWon: apiIsWon,
                      attempts: response.data.attempts,
                      gameTime: response.data.gameTime ?? 0,
                      wordInfo: {
                        word: response.data.correctAnswer,
                        difficulty: gameState.difficulty ?? 'medium',
                        length: response.data.correctAnswer.length,
                        definition: '‰ªéAPIËé∑ÂèñÁöÑÂçïËØç',
                        category: 'Âú®Á∫øÊ∏∏Êàè'
                      },
                      wordStats: {
                        totalAttempts: wordStats.totalAttempts,
                        totalSuccesses: wordStats.totalSuccesses,
                        successRate: wordStats.successRate,
                        averageAttempts: wordStats.averageAttemptsToWin ?? wordStats.totalAttempts,
                        averageGameTime: wordStats.averageGameTime,
                        perceivedDifficulty: wordStats.perceivedDifficulty,
                        sampleSize: wordStats.sampleSize,
                        lastPlayedAt: wordStats.lastPlayed ?? new Date().toISOString()
                      }
                    };
                    void handleGameComplete(apiIsWon, response.data.attempts, endGameData);
                  } else {
                    void handleGameComplete(apiIsWon, response.data.attempts);
                  }
                }
              } catch (endGameError) {
                console.warn('Ë∞ÉÁî® endGame API Â§±Ë¥•:', endGameError);
                // Â¶ÇÊûú endGame API Â§±Ë¥•Ôºå‰ΩøÁî®‰ªé guess API Ëé∑ÂèñÁöÑÊï∞ÊçÆ
                if (response.data.correctAnswer && wordStats) {
                  const endGameData: EndGameData = {
                    sessionId,
                    isWon: apiIsWon,
                    attempts: response.data.attempts,
                    gameTime: response.data.gameTime ?? 0,
                    wordInfo: {
                      word: response.data.correctAnswer,
                      difficulty: gameState.difficulty ?? 'medium',
                      length: response.data.correctAnswer.length,
                      definition: '‰ªéAPIËé∑ÂèñÁöÑÂçïËØç',
                      category: 'Âú®Á∫øÊ∏∏Êàè'
                    },
                    wordStats: {
                      totalAttempts: wordStats.totalAttempts,
                      totalSuccesses: wordStats.totalSuccesses,
                      successRate: wordStats.successRate,
                      averageAttempts: wordStats.averageAttemptsToWin ?? wordStats.totalAttempts,
                      averageGameTime: wordStats.averageGameTime,
                      perceivedDifficulty: wordStats.perceivedDifficulty,
                      sampleSize: wordStats.sampleSize,
                      lastPlayedAt: wordStats.lastPlayed ?? new Date().toISOString()
                    }
                  };
                  void handleGameComplete(apiIsWon, response.data.attempts, endGameData);
                } else {
                  void handleGameComplete(apiIsWon, response.data.attempts);
                }
              }
            }
          } else {
            throw new Error('API ËøîÂõûÂ§±Ë¥•');
          }
        } catch (error) {
          console.warn('API Êèê‰∫§ÁåúÊµãÂ§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞È™åËØÅ:', error);
          // Â¶ÇÊûú API Â§±Ë¥•ÔºåÈôçÁ∫ßÂà∞Êú¨Âú∞È™åËØÅ
          await performLocalValidation();
        }
      } else {
        // Ê≤°Êúâ sessionIdÔºå‰ΩøÁî®Êú¨Âú∞È™åËØÅÔºåÈúÄË¶ÅÂÖàËøõË°åËØçÂÖ∏È™åËØÅ
        console.log('üéÆ Êú¨Âú∞Ê®°ÂºèÔºåÂÖàËøõË°åËØçÂÖ∏È™åËØÅ');
        setIsValidating(true);
        const result = await dictionaryService.validateWord(currentWord);
        setIsValidating(false);
        
        console.log('üéÆ ËØçÂÖ∏È™åËØÅÁªìÊûú:', result);
        
        if (!result.isValid) {
          console.log('üéÆ ËØçÂÖ∏È™åËØÅÂ§±Ë¥•ÔºåÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ');
          setValidationResult(result);
          setIsChecking(false);
          return;
        }
        
        await performLocalValidation();
      }
      
             // Êú¨Âú∞È™åËØÅÂáΩÊï∞
       async function performLocalValidation() {
         if (!gameState) return;
         
         const states = computeLetterStates(newCells, gameState.targetWord);
         for (let i = 0; i < newCells.length; i++) {
           await sleep(CHECK_DELAY);
           const cell = newCells[i];
           if (cell) {
             newCells[i] = { ...cell, state: states[i] ?? 'not-found' };
             const cellLetter = cell.letter;
             const currentState = states[i];
             newKeyboardStates[cellLetter] = currentState ?? 'not-found';
             
             switch (currentState) {
               case 'found': playAudio(AUDIO_FILES.found); break;
               case 'wrong': playAudio(AUDIO_FILES.wrong); break;
               case 'not-found': playAudio(AUDIO_FILES.notFound); break;
             }
           }
         }

         // Ê£ÄÊü•ÊòØÂê¶Ëé∑ËÉú
         const isWon = isGameWon(newCells, gameState.targetWord);
         
         setGameState(prev => {
           if (!prev) return prev;
           
           const newRows = [...prev.rows];
           newRows[prev.currentRow] = {
             ...newRows[prev.currentRow]!,
             cells: newCells,
             isCompleted: true
           };
           
           let newGameStatus = prev.gameStatus;
           let newCurrentRow = prev.currentRow;
           
           if (isWon) {
             newGameStatus = 'won';
             playAudio(AUDIO_FILES.win);
             void handleGameComplete(true, prev.currentRow + 1);
           } else {
             newCurrentRow = prev.currentRow + 1;
             
             if (newCurrentRow >= 6) {
               newGameStatus = 'lost';
               void handleGameComplete(false, 6);
             }
           }
           
           return {
             ...prev,
             rows: newRows,
             currentRow: newCurrentRow,
             gameStatus: newGameStatus,
             keyboardStates: newKeyboardStates
           };
         });
       }
    } finally {
      setIsChecking(false);
    }
  }, [gameState, isChecking, handleGameComplete, sessionId]);

  // ‰ªéURLËé∑ÂèñÂçïËØçÊó∂ÁöÑÂàùÂßãÂåñ
  useEffect(() => {
    const urlWord = getWordFromUrl();
    if (urlWord !== 'cacophonie') {
      setGameState(createInitialGameStateWithDifficulty(urlWord, null));
      setGameMode('playing');
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const closeValidationResult = useCallback(() => {
    setValidationResult(null);
  }, []);

  const getGameStats = useCallback(async () => {
    try {
      type GetStatsAPIResponse = ApiResponse<GameStats>;
      const statsResponse = await gameSessionAPI.getStats() as GetStatsAPIResponse;
      
      if (statsResponse?.success && statsResponse?.data) {
        return statsResponse.data;
      } else {
        console.warn('Ëé∑ÂèñÊ∏∏ÊàèÁªüËÆ°Â§±Ë¥•:', statsResponse?.message);
        return null;
      }
    } catch (error) {
      console.warn('Ë∞ÉÁî®getStats APIÂ§±Ë¥•:', error);
      return null;
    }
  }, []);

  const contextValue: GameContextType = {
    // Ê∏∏ÊàèÁä∂ÊÄÅ
    gameState,
    sessionId,
    gameMode,
    selectedDifficulty,
    lastPlayedDifficulty,
    isChecking,
    isValidating,
    isLoadingWord,
    validationResult,
    isDailyChallenge,
    endGameData,
    
    // Ê∏∏ÊàèÊéßÂà∂
    handleKeyInput,
    handleVirtualKeyboard,
    closeValidationResult,
    handleGameComplete,
    
    // Ê®°ÂºèÂàáÊç¢
    returnToMainMenu,
    
    // ÈöæÂ∫¶ÂíåÊ∏∏ÊàèÁÆ°ÁêÜ
    handleDifficultySelect,
    startNewGame,
    startDailyChallenge,
    quickStart,
    restartGame,
    returnToDifficultySelection,
    getGameStats
  };

  return (
    <GameContext.Provider value={contextValue}>
      {children}
    </GameContext.Provider>
  );
};

// Ëá™ÂÆö‰πâ hook Êù•‰ΩøÁî® GameContext
export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
}; 